/**
 *  Java implementation of Secure Remote Password protocol, version 6
 *  @author  Josh Guyette
 *  @version 8/03/08
 */

import java.math.BigInteger;
import java.util.Random;
import java.security.MessageDigest;

public class SRP6
{
    // Constructor initialized variables
    private BigInteger modulus_N, salt, generator_g, multiplier_k;

    // Server calculated variables
    private BigInteger sIdentityHash, sVerifier, scrambler;
    
    // Common variables
    BigInteger sessionKey, privateKey, publicKey;

    public static void main(String[] args)    
    {
        String modulus = "115b8b692e0e045692cf280b436735c77a5a9e8a9e7ed56c965f87db5b2a2ece3";
        
        SRP6 srpServer = new SRP6("TEST", "test", modulus, 0x02, 256, 128);
        SRP6 srpClient = new SRP6("TEST", "test", modulus, 0x02, srpServer.getSalt());
        
        // This is the information that would normally be exchanged over
        // the network connection
        srpServer.setSessionKey(true, srpClient.getPublicKey(), null);
        srpClient.setSessionKey(false, srpServer.getPublicKey(), srpServer.getScrambler());
        
        System.out.println("=== SRP6 Demo Started ===");
        System.out.println("Modulus = " + srpServer.getModulus());
        System.out.println("Multiplier = " + srpServer.getMultiplier());
        System.out.println("Generator = " + srpServer.getGenerator());
        System.out.println("Salt = " + srpServer.getSalt());
        System.out.println("IdentityHash = " + srpServer.getIdentityHash());
        System.out.println("Verifier = " + srpServer.getVerifier());
        System.out.println("");
        System.out.println("ServerPrivateKey (b)= " + srpServer.getPrivateKey());
        System.out.println("ServerPublicKey (B)= " + srpServer.getPublicKey());
        System.out.println("Scramber (u)= " + srpServer.getScrambler());        
        System.out.println("");
        System.out.println("ClientPrivateKey (a) = " + srpClient.getPrivateKey());
        System.out.println("ClientPublicKey (A)= " + srpClient.getPublicKey());
        System.out.println("ClientIdentityHash (x) = " + srpClient.getIdentityHash());        
        System.out.println("");
        System.out.println("ServerSessionKey = " + srpServer.getSessionKey());
        System.out.println("ClientSessionKey = " + srpClient.getSessionKey());
        
        
    }
    
    // Server Constructor, Radix 16 strings, 256-bit predef values
    public SRP6(String user, String password, String modulus_N, int generator_g, int saltBits, int scramblerBits)
    {
        this.modulus_N = new BigInteger(modulus_N, 16);
        this.generator_g = new BigInteger("" + generator_g, 10);
        this.multiplier_k = new BigInteger("3", 10);
        this.salt = new BigInteger(saltBits, new Random());
        this.scrambler = new BigInteger(scramblerBits, new Random());
        
        // Server-side variables
        sIdentityHash = bytesToBig(SHA3Util.sha3Hash(bigToByteArray(salt), SHA3Util.sha3Hash(new String(user + ":" + password).getBytes())));
        
        sVerifier = this.generator_g.modPow(sIdentityHash, this.modulus_N);        
        
        privateKey = new BigInteger(128, new Random());
        // kv + g^b   (mod N)
        publicKey = this.multiplier_k.multiply(sVerifier).add(this.generator_g.modPow( privateKey, this.modulus_N ));
        
    }

    // Client Constructor, username not needed, salt not generated by client
    public SRP6(String user, String password, String modulus_N, int generator_g, String salt)
    {
        this.modulus_N = new BigInteger(modulus_N, 16);
        this.generator_g = new BigInteger("" + generator_g, 10);
        this.multiplier_k = new BigInteger("3", 10);
        this.salt = new BigInteger(salt, 16);
        
        
        // Client-side variables

        privateKey = new BigInteger(128, new Random());
        // g^a   (mod N)
        publicKey = this.generator_g.modPow(privateKey, this.modulus_N);
        
        // Server-side variables
        sIdentityHash = bytesToBig(SHA3Util.sha3Hash(bigToByteArray(this.salt), SHA3Util.sha3Hash(new String(user + ":" + password).getBytes())));

    }

    public void setSessionKey(boolean server, String pubKeyString, String scram)
    {
        BigInteger pubKey = new BigInteger(pubKeyString, 16);
        if (server)
        {
            // (Av^u) ^ b   (mod N)
            sessionKey = pubKey.multiply(sVerifier.modPow(scrambler, modulus_N)).modPow(privateKey, modulus_N);
        }
        else {
            this.scrambler = new BigInteger(scram, 16);
            
            BigInteger temp = privateKey.add(scrambler.multiply(sIdentityHash));
            sessionKey = pubKey.subtract((generator_g.modPow(sIdentityHash, modulus_N)).multiply(multiplier_k)).modPow(temp, modulus_N);
        }
    }
    
    public String getSessionKey()
    {
        return bytesToHex(bigToByteArray(sessionKey));
    }

    public String getMultiplier()
    {
        return bytesToHex(bigToByteArray(multiplier_k));
    }

    public String getScrambler()
    {
        return bytesToHex(bigToByteArray(scrambler));
    }
    
    public String getGenerator()
    {
        return bytesToHex(bigToByteArray(generator_g));
    }
    
    public String getPrivateKey()
    {
        return bytesToHex(bigToByteArray(privateKey));
    }
    
    public String getPublicKey()
    {
        return bytesToHex(bigToByteArray(publicKey));
    }
    
    public String getModulus()
    {
        return bytesToHex(bigToByteArray(modulus_N));
    }
    
    public String getIdentityHash()
    {
        return bytesToHex(bigToByteArray(sIdentityHash));
    }

    public String getSalt()
    {
        return bytesToHex(bigToByteArray(salt));
    }
    
    public String getVerifier()
    {
        return bytesToHex(bigToByteArray(sVerifier));
    }
    
    private byte[] hash(byte[] input1)
    {
        return hash(input1, null);
    }
    private byte[] hash(byte[] input1, byte[] input2)
    {
        try {
            MessageDigest sha = MessageDigest.getInstance("SHA-1");
            sha.update(input1);
            if (input2 != null)
                sha.update(input2);
            return sha.digest();
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
    
    private static String byteToHex(byte data)
    {
        StringBuffer buf = new StringBuffer();
        buf.append(toHexChar((data>>>4)&0x0F));
        buf.append(toHexChar(data&0x0F));
        return buf.toString();
    }
    
    private static String bytesToHex(byte[] data) {
        if (data == null)
            return "";
        StringBuffer buf = new StringBuffer();
        data = trim(data);
        for ( int i = 0; i < data.length; i++ )
            buf.append( byteToHex(data[i]) );
        String output = buf.toString();
        //if ((output.charAt(0) == '0') && (output.charAt(1) == '0'))
        //    output = output.substring(2, output.length() - 1);
        return output;
    }

    private static char toHexChar(int i)
    {
        if ((0 <= i) && (i <= 9 ))
            return (char)('0' + i);
        else
            return (char)('a' + (i-10));
    }        
    
    private static byte[] trim(byte[] data)
    {
        if (data[0] == 0)
        {
            byte[] oldData = data;
            data = new byte[ oldData.length - 1];
            for (int i = 0; i < data.length; i++)
                data[i] = oldData[i + 1];
        }
        return data;
    }
        
    private static byte[] bigToByteArray(BigInteger bigI)
    {
        if (bigI == null)
            return new byte[] { 0 };
        //System.out.println("bigToByteArray: " + bigI.toString(16));
        //System.out.print("bigToByteArray: bytes = ");
        byte[] temp = bigI.toByteArray();
        
        if (temp[0] == 0)
        {
            byte[] out = new byte[  temp.length - 1 ];
            for (int i = out.length - 1; i >= 0; i--)
                out[i] = temp[i + 1];
            //for (int i = 0; i < out.length; i++)
            //    System.out.print("" + out[i] + ", ");
            //System.out.println("(end)");
            return out;
        }
        //for (int i = 0; i < temp.length; i++)
        //    System.out.print("" + temp[i] + ", ");
        //System.out.println("(end)");
        return temp;
    }
    
    private static BigInteger bytesToBig(byte[] bytes)
    {
        return new BigInteger(bytesToHex(bytes), 16);
    }

}
